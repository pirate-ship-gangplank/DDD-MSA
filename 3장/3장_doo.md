# 관심사 분리

**관심사 분리** : 시스템의 각 영역이 처리하는 관심사에 따라 분리되어 있는 것

- 비즈니스를 처리하는 객체 모델은 없고, **모든 업무 로직이 데이터 질의 구문인 SQL에 들어있는 경우**가 많다.

**[ 비즈니스 로직을 SQL로만 처리하면 발생하는 문제 ]**

- 특정 벤더에 의존성이 높아져서 나중에 변경을 하는 데에 어려움이 있다.
- 비즈니스 로직이 SQL에 몰려있다보니 데이터베이스의 성능이 점차 나빠지고, 데이터베이스가 병목 지점이 될 수 있다.
- 스케일 아웃을 해도 비즈니스 로직은 바쁘지않고 데이터베이스만 바쁘기 때문에 의미가 없고, 데이터베이스 자체의 스케일업이나 SQL문 튜닝에 대해 몰두할 수밖에 없다.
→ SQL문을 압축하여 튜닝하면 더더욱 이해가 가지 않는 SQL문이 만들어질 가능성이 있다.

### 데이터베이스 중심 아키텍처의 문제점

**데이터베이스 중심 아키텍처** : **특정 관계형 데이터베이스에 의존한 데이터 모델링**을 수행한 다음, 이 **물리 테이블 모델을 중심에 두고 애플리케이션을 구현**하기 위한 사고를 하는 방법

일반적인 스프링 프레임워크는 컨트롤러, 서비스, 데이터베이스, DTO로 구성된다.

- 위 그림에서는 **비즈니스 규칙과 데이터 처리**가 모두 **데이터베이스 단**에 있다.
- 비즈니스 로직이 서비스단에 있어야한다고 말하지만, 실제로는 **서비스는 그저 흐름 제어 로직으로만 쓰일 뿐**이고 그 밖의 **비즈니스 개념과 규칙**들은 **테이블과 SQL 질의에 존재**한다.
- 데이터베이스에서 비즈니스 로직을 처리하기 때문에 **애플리케이션에서는 딱히 할 일이 없다**.
→ 클라우드 인프라의 가장 큰 장점인 사용량에 유연하게 대응하는 **스케일 아웃이 의미가 없어진다**.
→ **데이터가 늘어남**에 따라 **데이터베이스 성능은 계속 떨어지고**, 이를 해결하기 위해 데이터베이스 사양과 용량을 계속 증가시키고 SQL 튜닝에 몰두할 수밖에 없다.

# 헥사고날 아키텍처와 클린 아키텍처

## 레이어드 아키텍처

레이어는 물리적인 장비나 서버 컴퓨터 등의 물리층을 의미하는 티어가 아니라, **티어 내부의 논리적인 분할**을 의미한다. 즉, **레이어드는 논리적인 개념**이다. 

- 레이어드 아키텍처는 물리적인 서버 티어 안에서 **프레젠테이션, 비즈니스 로직, 데이터 액세스의** 3개의 논리적인 계층으로 분할한 것이다.
- **프레젠테이션** : 화면 표현 및 전환 처리
- **비즈니스 로직** : 비즈니스 개념, 규칙, 흐름 제어
- **데이터 액세스** : 데이터 처리

**[ 레이어드 아키텍처 규칙 ]**

- 상위 계층이 하위 계층을 호출하는 **단방향성**을 유지한다.
- 상위 계층은 하위의 여러 계층을 모두 알 필요 없이 **바로 밑의 근접 계층만 활용**한다.
- 상위 계층이 **하위 계층에 영향을 받지 않도록** 구성해야 한다.
- 하위 계층은 자신을 사용하는 **상위 계층을 알지 못하게** 구성해야 한다.
- 계층 간의 호출은 **인터페이스를 통해 호출**하는 것이 바람직하다.
→ 구현 클래스에 직접 의존하지 않음으로서 약한 결합을 유지한다.
→ 질문 : OrderService 같은 인터페이스와 OrderServiceImpl 같은 구현체를 만들라는 의미 같은데, 꼭 인터페이스를 통해 호출을 해야하나?

**의존성 역전 원칙 (DIP)** : 소스코드 의존성이 **추상에 의존**하며, **구체에는 의존하지 않는 것**

레이어드 아키텍처는 **DIP는 만족하지만, OCP는 만족하지 못한다.**
→ 왜냐하면, 모든 계층이 각기 자신이 제공하는 기능에 대한 **추상적인 인터페이스를 직접 정의하고 소유하고 있는 구조이기 때문**이다.

질문 : 인터페이스가 바뀌면 당연히 상위 계층에도 변경이 필요한거 아닌가? 변경 없이 인터페이스 변경이 가능한건가?
근데 애초에 인터페이스를 변경한다의 의미가 뭐지? 파라미터가 추가되는건가, 메서드명이 변경되는건가, 리턴 타입이 변경되는건가? 아니면 또 다른 변경점이 있는건가? 그게 어떤 변경이든 상위 계층이 하위 계층을 사용하는 한 인터페이스가 변경되면 코드를 변경하는 일은 필수가 아닌가??

**해결책** : 문제는 **하위 계층의 인터페이스 위치**이다. 데이터 액세스 계층에서 정의한 인터페이스를 경계를 넘어 **비즈니스 로직 계층으로 옮긴다**. 그러면 데이터 액세스 계층의 구현체는 비즈니스 로직의 계층의 인터페이스를 바라볼 수밖에 없다. 

## 헥사고날 아키텍처

고수준의 비즈니스 로직을 표현하는 내부 영역과 인터페이스를 담당하는 저수준의 외부 영역으로 나눈다.

- **내부 영역**은 순수한 **비즈니스 로직을 표현하는 기술 독립적인 영역**이다. 그리고 **외부 영역과 연계되는 포트**를 가지고 있다.
- **외부 영역**은 **외부에서 들어오는 요청을 처리하는 '인바운드 어댑터'**와 **비즈니스 로직에 의해 호출되어 외부와 연계되는 '아웃바운드 어댑터'**로 구성된다.
- 고수준의 **내부 영역이 외부의 구체 어댑터에 전혀 의존하지 않게 한다**는 것이 가장 큰 특징이다.
→ 내부 영역에 구성된 **포트**를 통해 가능하다.

## 클린 아키텍처

클린 아키텍처는 여러 겹으로 둘러싸인 영역으로 표현하며, 중앙에서부터 밖으로 엔티티, 유스케이스, 그 외 세부사항으로 구분한다.

- **엔티티** : **가장 안쪽**에 있으며, **업무 규칙에 필요한 데이터를 객체화**시킨 것이다.
- **유스케이스(use case)** : **업무 규칙을 표현**하며, **엔티티 내부의 핵심 업무 규칙을 호출**하며 시스템을 사용하는 흐름을 담는다. 
→ 고수준 영역의 엔티티는 저수준 영역의 유스케이스에 대해 몰라야하며, **엔티티는 유스케이스를 통해서만 조작**되어야 한다.
- **그 외 세부사항** : 유스케이스를 감싸고 있고, 세부 사항과 유스케이스의 관계를 플러그인처럼 유연하게 둬야한다. 세부사항 ex) 입출력 장치, 저장소, 서버, 프레임워크, 통신 프로토콜 등

# 마이크로서비스의 내부 구조 정의

## 클린 마이크로서비스

- 각 마이크로서비스는 폴리글랏하게 만들어질 수 있으며, 적절한 언어와 저장소를 사용하여 만든다.
- 아주 간단한 마이크로서비스에 헥사고날 아키텍처나 클린 아키텍처를 적용할 필요는 없지만, 복잡한 마이크로서비스엔 적용하는 것이 바람직하다.

**[ 레이어드, 헥사고날, 클린 아키텍처가 지향하는 원칙들 ]** 

- 지향하는 관심사에 따라 응집성을 높이고 관심사가 다른 영역과는 의존도를 낮추게 해야 한다.
- 업무 규칙을 정의하는 비즈니스 로직 영역을 다른 기술 기반 영역으로부터 분리한다.
- 세부 기술 중심, 저수준의 외부 영역과 핵심 업무 규칙이 정의된 고수준의 내부 영역으로 분리한다.
- 고수준 영역은 저수준 영역에 의존하지 않게 하며, 저수준 영역이 고수준 영역에 의존하게 한다.
- 저수준 영역은 언제든 교체 및 확장이 가능해야 하며, 이러한 변화가 고수준 영역에 영향을 주면 안된다.
- 저수준 영역의 구체 클래스가 고수준 영역의 추상 인터페이스에 의존하는 DIP를 적용한다.
- 인터페이스는 고수준의 안정된 영역에 존재해야 하며, 저수준의 어댑터가 이를 구현한다.

**[ 마이크로서비스의 내부 구조 예시 ]**

- 내부 영역에서는 맨 안쪽에 **도메인**이 존재하고, **서비스**가 도메인을 감싼다. 
→ **도메인에는 핵심 비즈니스 개념과 규칙**을 구현하며, **서비스에서는 도메인을 호출해서 업무를 처리**하는 절차를 기술한다.
→ 추가로 외부 영역과 연계하기 위한 **서비스 인터페이스를 보유**한다. 서비스 인터페이스는 외부에서 내부 영역을 사용할 수 있도록 API를 제공한다.
- 저장소 처리를 위한 **레포지토리 인터페이스**는 외부 영역에서 정의하지않고 내부 영역에서 정의하는데, 비즈니스를 처리하는데 필요한 기본적인 저장소 처리 사항을 추상화해 정의한다.
- **외부 영역**에는 저장소 처리 어댑터, 인바운드 및 아웃바운드를 처리하는 **어댑터가 위치**한다. 
→ 모든 **아웃바운드 어댑터는 외부 영역에서 내부 영역에 의존하도록 설계**한다.

## 내부 영역 - 업무 규칙

내부 영역에는 서비스 인터페이스, 서비스 구현체, 도메인, 리포지토리 인터페이스, 도메인 이벤트 인터페이스, API 프록시 인터페이스가 있다.

안정적인 **고수준의 내부 영역에 인터페이스가 존재**하고, **저수준의 외부 어댑터가 이러한 인터페이스를 구현**하게 한다.

### 트랜잭션 스크립트 패턴

**도메인 객체**가 **속성(필드)만 가지고 있고, 행위는 가지고 있지 않는 패턴**

- 도메인 객체에 행위가 없기 때문에, 모든 **비즈니스 행위를 수행하는 책임은 서비스**에 있다.
- 서비스가 점점 비대해지면, 자연스럽게 **도메인 객체는 정보 묶음의 역할만 수행**하게 된다.
- 추후에 유지보수를 어렵게 할 수 있다.
- 비즈니스가 간단한 경우엔 쉽게 적용할 수 있어서, 간단한 비즈니스 처리에 적용할 땐 좋을 수 있다.

### 도메인 모델 패턴

**도메인 객체가 데이터뿐 아니라 비즈니스 행위를 가지고 있는 패턴**

- **도메인 객체가 소유한 데이터**는 **도메인 객체가 제공하는 행위에 의해 은닉**된다.
- **서비스의 책임들이 도메인으로 적절히 분산**되기 때문에 서비스가 비대해지지 않고, **서비스 로직이 단순**해진다.
- 거대한 서비스 클래스 대신 **각기 적절한 책임을 가진 여러 클래스**로 구성되어, **이해하기 쉽고 관리 및 테스트하기 쉽다**.
- 도메인 주도 설계의 **애그리거트 패턴**을 적용할 수 있는 구조이다.

### 애그리거트 패턴

**최상위에 존재하는 엔티티(Root Entity)를 중심으로 개념의 집합을 분리한 패턴**이다.

- **1개 이상의 엔티티와 값 객체(VO)로 구성**되는데, **개념적으로 묶인 엔티티의 모음 전체**를 애그리거트라고 한다.
- 점점 복잡해질 수 있는 객체 모델링의 단점을 보완한 패턴

**[ 애그리거트 패턴 규칙 ]**

- 애그리거트 루트만 참조한다.
- 애그리거트 내 상세 클래스를 바로 참조하지 않고 루트를 통해 참조해야 한다. (수정도 마찬가지다)
- 애그리거트 간의 참조는 객체를 직접 참조하는 대신 기본키를 사용한다.
→ 기본키를 사용하면 느슨하게 연관되고, 수정이 필요하지 않은 애그리거트를 함께 수정하는 실수를 방지
- 하나의 트랜잭션으로 하나의 애그리거트만 생성 및 수정한다.

## 외부 영역 - 세부사항

**외부 영역**은 내부 영역의 **서비스 인터페이스를 사용하는 인바운드 어댑터**와 내부 영역에서 선언한 **아웃바운드 인터페이스를 구현하는 다양한 어댑터**로 구성한다.

- 어댑터는 플러그인처럼 언제든지 교체되거나 확장될 수 있어야 한다.
- 내부 영역이 먼저 정의된 후에 외부 영역의 세부사항은 늦게 정의돼도 상관없도록 해야 한다.

### API 퍼블리싱 어댑터

REST API를 발행하는 인바운드 어댑터이다. 

- 내부 영역의 서비스 인터페이스를 호출해서 REST 형식의 API로 제공한다.
- 엔티티를 직접 제공하지 않고 DTO를 생성해서 전달하는 것이 바람직하다.
→ 엔티티를 직접 제공하면, 클라이언트에 도메인 규칙이 유출된다.

### API 프록시 어댑터

다른 서비스의 API를 호출하는 아웃바운드 어댑터이다.

- 내부 영역에 정의된 프록시 인터페이스를 구현하며, 다른 서비스의 API는 REST API가 될 수도 있고 소켓이나 SOAP 프로토콜을 사용하는 API일 수도 있다.

### 저장소 처리 어댑터

- **ORM 방식**과 **SQL 맵핑 방식**을 사용할 수 있다.

**[ ORM ]**

- 도메인 모델 패턴을 사용할 경우 많이 선택한다.
- JPA나 Spring Data가 많이 사용된다.
- 런타임 시 저장소에 따라 자동으로 질의문을 생성한다.
    - SQL 작성에 따르는 개발자의 작업량을 줄여준다.
    - 저장소를 보다 쉽게 변경할 수 있다.

**[ SQL 매퍼 ]**

- 트랜잭션 스크립트 패턴을 사용할 경우 많이 선택한다.
- 마이바티스를 주로 사용한다.
- SQL 질의문을 수동으로 작성해야 하므로 세밀한 SQL 제어가 필요한 경우에 유용하다.
- SQL 질의문을 직접 작성해야해서 개발자의 작업량이 늘어나며, 저장소 교체가 어렵다.

### 도메인 이벤트 발행 어댑터

**도메인에서 발생한 도메인 이벤트를 컨슈머에게 발행하는 어댑터**이다.

- 도메인 이벤트가 실제로 생성되는 위치는 내부 영역이다.
- 내부 영역의 이벤트 인터페이스를 구현해서 아웃바운드로 특정 메세지 큐나 스트림 저장소에 발행하는 역할을 수행한다.

### 도메인 이벤트 핸들러

**발행된 도메인 이벤트를 수신할 수 있는 인바운드 어댑터**이다.

- 외부에서 발행된 도메인 이벤트를 구독해서 내부 영역으로 전달하는 역할을 수행한다.
- 이벤트 상태에 따라 적절한 서비스 인터페이스를 호출해서 내부 영역에 이벤트를 전달한다.