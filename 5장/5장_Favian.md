# 5장 : 마이크로서비스 설계

마이크로서비스 설계에서 가장 중요한 관심사

- 어떻게 기능적으로 응집성 있는 마이크로서비스를 도출할 것인가?

- 어떻게 타 서비스 간의 의존도는 낮출 것인가?

## 5.1 : 마이크로서비스를 도출하는 방법

### 5.1.1 : 비즈니스 능력에 근거한 도출

각 도메인에서는 비즈니스가 규정하는 일하는 방식과 조직, 부서 체계가 이미 정의돼 있고,

이미 업무 처리에서의 응집성을 가지고 있고 타 부서와의 의존도는 낮을 것

비즈니스 부서가 가진 역할, 처리 능력을 체계적으로 분해할 수 있으며, 보통 이를 업무 기능 분해라고 한다

업무 흐름에 따라 업무를 최상위에서 하위까지 대, 중, 소의 크기로 분리하고 수행하는 일들을 체계적으로 정렬한다

이러한 방식은 전체적인 대략의 비즈니스를 이해할 때는 유용하지만, 서비스 간의 관게 파악이나 서비스 구체 기능과 연관된 서비스가 관리할 독립적인 데이터를 식별하기에는 미흡하다

### 5.1.2 : DDD의 바운디드 컨텍스트 기반 도출

서비스가 보유한 기능에 의해서만 접근 가능한 데이터를 파악할 필요가 있다

앞서 설명한 기능 분해 방식은 서비스가 소유해야 할 데이터 식별에 적합하지 않고, 기능과 데이터가 분리되고 하나의 통합 데이터가 여러 기능에서 사용되도록 모델링되는 방식

DDD에서는 데이터를 기능과 분리해서 식별하지 않고 문제 영역인 하위 도메인마다 별도의 도메인 모델로 정의한다

## 5.2 : DDD에서의 설계

클라우드, 마이크로서비스 아키텍처에서 얻을 수 있는 장점

- 독립적 개선과 배포
- 장애 격리
- 장애 발생 시 빠른 재실행

이러한 것들이 가능하려면 마이크로서비스를 응집성 있게 식별해야 한다

비즈니스 응집성이 있는 컨텍스트를 바운디드 컨텍스트라 하고, 이 단위가 마이크로서비스를 식별하기 위한 훌륭한 단위가 될 수 있다

## 5.3 : DDD의 전략적 설계

### 5.3.1 : 도메인과 서브도매인

많은 개념들이 하나로 엮인 복잡한 비즈니스 도메인을 논리적으로 구분되는 여러 개의 하위 영역으로 분리 해야 한다

서브 도메인은 중요도에 따라 3가지 유형으로 나뉜다

- 핵심 서브도메인

다른 경쟁자와 차별화를 만들 비즈니스 영역, 높은 우선순위를 갖는 영역 & 전략적으로 가장 큰 투자가 필요한 영역

> .ex) 아마존의 상품 추천 영역, 쿠팡 로켓배송

- 지원 서브도메인

비즈니스에 필수적이지만 핵심은 아닌 부분

- 일반 서브도메인

비즈니스적으로 특화된 부분은 아니지만 전체 비즈니스 솔루션에는 필요한 부분으로, 기존 제품을 구매해서 대체할 수 있다

### 5.3.2 : 유비쿼터스 언어와 도메인 모델, 바운디드 컨텍스트

- 바운디드 컨텍스트 : 도메인의 주요 개념을 정의하고 도메인 간의 경계를 식별하는 영역

- 유비쿼터스 언어 : 도메인의 모든 구성원이 공통으로 사용하는 언어

실제 의사소통에서 업무자와 개발자가 다르게 해석할 수 있고, 특정한 상황에 따라 의미가 다르게 해석될 수 있는 여지가 있기에 **단어/용어사전** 등이 필요하다

유비쿼터스 언어를 정의해서 이해관계자가 모두 공통의 언어를 사용하면 특정 업무와 관련된 사람들 간에 용어에 따른 오해를 없앨 수 있게 된다

표준 단어/용어 사전과는 다른 개념은, 전체 시스템에서 하향식으로 규정되는게 아니라 업무와 관련된 사람들 간에 자율적으로 정의되고 통용되는 개념이다

> ex) 결제 도메인의 고객과 배송 도메인에서 고객은 의미가 다르다

도메인 별 언어가 달라지는 경계가 **바운디드 컨텍스트**이다

### 5.3.3 : 컨텍스트 매핑

바운디드 컨텍스트를 식별할 때 각 컨텍스트는 응집성이 높고, 다른 컨텍스트와 의존관계가 낮아야 한다는 원칙하에 설계된다

하지만 식별하다 보면 비즈니스 수행을 위해 여러 개의 컨텍스트가 연계해야 하는 경우가 발생한다

이러한 의존 관계를 DDD에서는 컨텍스트 매핑이라 하고 선을 그려 표현한다

#### 주요 컨텍스트 매핑 관계

- 공유 커널

두 개 이상의 팀에서 작지만 공통의 모델을 공유하는 관계

보통 공통 라이브러리 등이 여기에 해당하는데, 변경되면 여러 관련 컨텍스트에 영향을 미치므로 공유하는 모델의 코드 빌드를 관리하고 테스트 하는 것은 한 팀이 맡아 수행해야 한다

- 소비자와 공급자

공급하는 컨텍스트는 상류, 소비하는 컨텍스트는 하류로 표시한다

데이터의 흐름은 상류에서 하류로 흐르고, 반대는 존재하지 않기에 상류 변화가 있다면 하류에서 변화를 따라야 한다

즉, 공급자는 소비자가 원하는 기능을 제공해야 한다

- 준수자

소비자와 공급자와 유사하지만 상류 팀이 하류 팀의 요구를 지원하지 않거나 못하는 경우에

하류팀은 상류팀에서 제공하는 모델을 그대로 사용한다

- 충돌 방지 계층

하류 팀이 상류 팀의 모델에 영향을 받을 때 하류 팀의 고유 모델을 지키기 위한 번역 계층을 만드는 것

이러한 매핑은 새로운 시스템을 레거시 시스템과 통합하기 위해 주로 사용 된다

> 레거시 시스템의 기존 통식 방법이 새로운 시스템이 규정한 REST AIP 방식을 지원하지 않을 경우 레거시 시스템이 변경될 필요가 있다

이를 통해 레거시 시스템이 클라우드 환경으로 이전되는 경우에도 이미 클라우드에 구축된 시스템을 변경할 필요 없이 충돌 방지 계층만 없애고,

서로 직접 연동하도록 호출 주소만 변경하면 된다

- 공개 호스트 서비스

바운디드 컨텍스트에 대한 접근을 제공하는 프로토콜이나 인터페이스를 정의한다

하류 컨텍스트가 상위 컨텍스트에서 제공하는 기능을 용이하게 사용할 수 있도록 공개돼 있다

> 다른 컨텍스트에서 사용할 수 있는 공유된 API가 여기에 해당한다

- 발행된 언어

하류의 컨텍스트가 상류 컨텍스트가 제공하는 기능을 사용하게 하기 위한 간단한 사용과 번역을 가능케 하는 문서화된 정보 교환 언어

> XML 이나 JSON 스키마로 표현될 수 있으며, 공개 호스트 서비스와 짝을 이뤄 사용된다

- 컨텍스트 맵

하나의 큰 도메인을 여러 개의 바운디드 컨텍스트로 식별하고 이들 간의 관계를 표현한 그림

전략적 설계로 도출된 컨텍스트를 기반으로 컨텍스트 매핑 관계를 표현한 개념적인 컨텍스트 맵은 아직 매핑을 위한 구체적인 기술 등이 정의되지 않은 상태

매핑을 구현할 방안이 구체화되면 컨텍스트 매핑 유형들을 구체적으로 표현할 수 있다

> 주로 공급자는 일반 서브도메인, 소비자는 핵심 서브도메인이다

## 5.4 : 이벤트 스토밍을 통한 마이크로서비스 도출

마이크로서비스 간의 의존성을 줄이기 위해서는 아키텍처 영역에서 서비스 간 비동기 메시지 기반 도메인 이벤트를 활용하는 것이 중요하다

이러한 도메인 이벤트를 통한 의존 관계를 식별하는 방법이 쉽지 않다

이를 위해 이벤트 스토밍이라는 설계 기법을 고안했는데, 이벤트 중심으로 이해관계자들이 모여 브레인 스토밍하는 워크숍을 의미한다

- 이벤트 스토밍

이해관계자가 모여 서로가 가지고 있는 각 관점을 논의

차이점을 이해하고 공유할 수 있다 -> 민첩성과 효율성을 보여준다

쉽고 간편한 도구를 사용해 빠른 시간 내에 지식 공유를 통한 협업을 가속화하고 시각화함으로써 서로간의 학습 및 탐색을 촉진하는 워크숍

### 5.4.1 : 이벤트 스토밍 워크숍 준비

이벤트 스토밍을 통해 도출된 바운디드 컨텍스트는 마이크로서비스 후보가 된다

- (비즈니스 측면) 비즈니스 프로세스를 수행하기 위한 하나의 맥락의 단위로 구분될 수 있는가?
- (데이터 관점) 마이크로서비스별로 분리된 데이터를 정의할 수 있는가?
- (운영 조직 측면) 하나의 팀이 독립적으로 운영 가능한 단위인가?
- (배포 측면) 독립적으로 배포 가능한 단위인가?
- (변경 영향도) 변경 시 영향을 받는 마이크로 서비스가 존재하는가?
- (클라우드/MSA 도입 목적 측면) 도입을 통한 기대효과를 충분히 활용할 수 있는가?

이를 모두 만족한다면 바운디드 컨텍스트를 최종 마이크로서비스로 식별,

만족하지 못한다면 각 질문의 결과에 따라 바운디드 컨텍스트를 분리하거나 통합해서 마이크로서비스로 식별한다

## 5.5 : 마이크로서비스 상세설계

### 5.5.2 백엔드 모델링

헥사고날 아키텍처를 적용해 외부 영역, 내부 영역으로 구분되어 진행된다

- API 설계

프런트엔드, 백엔드 엔지니어가 하나의 팀에서 긴밀하게 협업해야 하고, 이를 위해서는 계약이 필요한데 그것이 **API 설계**다

API 영역은 헥사고날의 외부 영역이며, 인바운드 어댑터로써 어떠한 호출 방식도 허용되는 유연한 공간이다

- REST API의 개념

아키텍처를 표현하는 구성요소로 자원(Resource), 행위(Verb), 표현(Representations)가 있다

> 홍길동이라는 사용자들 생성한다 (자원 : 사용자, 행위 : 생성한다, 표현 : 홍길동)

```json
HTTP POST http://example.com/users/
{
  "users" : {
            "name" : "홍길동"
  } 
}
```

자원은 http://example.com/users/ URI로 표현되고, 생성을 위한 HTTP 메서드 POST를 사용했고, JSON 문서의 형태로 구체적인 사용자로 표시(전달)된 것이다

이렇게 REST API의 구성요소만 보고 API의 내용을 직관적으로 이해할 수 있으므로 최소한의 문서로써 설명할 수 있고 매우 쉽게 사용할 수 있다

- REST API 성숙도

**레벨 0**

REST API의 메커니즘을 전혀 사용하지 않고 전통적인 원격 프로시저 호출 방식으로 HTTP 프로토콜만 사용한 것

> GET /service?Flag=create

백엔드 내부에서 비즈니스 로직을 통해 어떠한 결정을 하는지 사용자는 API를 보고는 알 수 없기에 API 명세가 필요하다

**레벨 1**

URI에 개별적인 자원을 표현하는 것

> /products/apple

특정 리소스가 어떠한 정보를 제공하는지 인지할 수 있다

**레벨 2**

서비스의 기능을 처리하기 위해 약속된 HTTP 메서드들을 사용하는 것

조회, 추가, 수정, 삭제 기능을 HTTP 메서드인 GET, POST, PUT, DELETE 로 각각 처리한다

이로 인해 API 사용자는 리소스에 어떠한 메서드를 사용했을 때 어떤 행위가 발생할지 인지할 수 있다

**레벨 3**

특정 요청을 하게 되면 반환값에 기대했던 결과에 덧붙여 추가로 사용자가 그 다음에 무엇을 할 수 있는지와 그것을 하기 위해 다룰 수 있는 URI 값을 보내준다

즉, 사용자에게 좀 더 리소스를 탐색해서 활용할 수 있는 가능성을 제공한다

- API 설계 문서화

공식적인 문서 형식이 필요하다면 엑셀 형태로 정리하는 것이 편한데,

다음 항목은 포함되도록 한다

**서비스명, API명, 리소스(URI)**
**요청 매개변수, 요청 샘플**
**응답 매개변수, 응답 샘플**

## 5.6 : 도메인 모델링

- 폴리글랏하다

내부 아키텍처 구조를 서비스 특성에 맞게 다양하게 수립할 수 있다는 의미

서비스 내부 영역의 구조를 도메인ㄴ 모델 중심으로 만들 수도 있고 트랜잭션 스크립트 형태로 만들 수도 있다

단순한 로직인 경우에는 트랜잭션 스크립트 구조로 만들어도 무방하다

비즈니스가 복잡해질수록 비즈니스 개념들을 잘 구조화할 수 있는 도메인 모델 구조가 효과적이다

### 5.6.1 : DDD의 전술적 설계(도메인 모델링 구성요소)

기존 객체 모델링 방식은 자유도가 높아 문제 영역을 파고들수록 여러 층의 복잡한 계층 구조를 만들게 될 가능성이 높다

이를 정리하기 위해 객체들의 역할게 따른 유형을 정의하고, 이러한 규칙에 따라 모델링하면 단순하고 이해하기 수월하다

이러한 설계 기법을 DDD의 전술적 설게에서 제공한다

#### 엔티티

다른 엔티티와 구별할 수 있는 식별자를 가진 도메인의 실체 개념을 표현하는 객체

식별자는 고유하되 속성 및 상태는 계속 변할 수 있다

도메인에서 개별성이 있는 개념을 엔티티로 식별하며, 고유 식별자와 변화 가능성이 엔티티와 값 객체를 구분하는 차이점이다

#### 값 객체

각 속성이 개별적으로 변화하지 않는 개념적 완전성을 모델링한다

속성과 속성의 합에 의해 전체 개념이 부여되며, 개별 속성이 별개로 수정되지 않고 전체 객체가 한 번에 생성 or 삭제되는 객체다

식별자의 차이에 따라 구별되지 않고 속성과 속성으로 이루어진 값의 비교에 의해 동일함이 결정된다

- 도메인 내의 어떤 대상을 측정하고, 수량화하고, 설명한다
- 관련 특징을 모은 필수 단위로 개념적 전체를 모델링한다
- 측정이나 설명이 변경될 땐 완벽히 대체 가능하다
- 다른 값과 등가성을 사용해 비교할 수 있다
- 값 객체는 일단 생성되면 변경할 수 없다

#### 표준 타입

대상의 타입을 나타내는 서술적 객체다

엔티티나 값 객체의 속성을 구분하는 용도로 사용된다

#### 애그리거트

엔티티와 값 객체로 모델링하게 되면 객체 간의 계층구조가 만들어진다. 이처럼 연관된 엔티티와 값 객체들의 묶음이 애그리거트다

1 ~ 2개의 엔티티, 값 객체, 표준 타입으로 구성되고, 이들 간에는 비즈니스 의존관계를 맺고 있고, 비즈니스 정합성을 맞출 필요가 있다

애그리거트 단위가 트랜잭션 단위가 된다

다른 애그리거트를 참조해야 할 필요가 있다면 직접 참조하지 않고 참조할 애그리거트 루트의 식별자를 통해 참조하게 한다

다른 애그리거트 사이의 일관성이 필요하다면 도메인 이벤트를 통한 결과적 일관성을 사용해 다른 애그리거트를 갱신해서 일관성을 유지한다


#### 도메인 서비스
3

도메인의 비즈니스 로직 처리가 특정 엔티티나 값 객체에 속하지 않을 때 단독 객체를 만들어서 처리하게 되는데, 이를 도메인 서비스라 한다

상태를 관리하지 않고 행위만 존재한다

#### 도메인 이벤트

도메인 이벤트는 DDD 및 이벤트 스토밍에서 말하는 도메인 이벤트의 구현 객체다

서비스간 정합성을 일치시키기 위해 단위 애그리거트의 주요 상태 값을 담아 전달되도록 모델링한다



